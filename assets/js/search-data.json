{
  
    
        "post0": {
            "title": "Image Classifications Techniques",
            "content": "This is going to be my first blog. I would like to start by stating the motivation for starting this. The main reason for starting is because people I respect in the deep learning (DL) community have all advocated for blogging as part of the learning process. Hence, I am hoping to articulate my learning and understanding through these blogs. It also means I am open to anyone correcting my understanding as well as to add to my current understanding. My blog is mostly going to be around DL and fastai. This year one of my goals is to be around the fastai community so I could learn from the amazing people and the conversation that takes place there. . In this blog, we will go through methods/techniques that help in image classification tasks. The following are the techniques I have been learning and as much as I can I would reference where I learnt the techniques from so anyone could learn from the source. The examples/codes will be using the fastai library. . Image classification is possibly the first task one would encounter when learning DL. Image classification is a computer vision task where a model classifies an image. For example, a cat or dog classifier classifies whether an image is a cat or a dog. . The types of image classifiction tasks . binary image classification - a task in which the model has to predict between two classes (eg. cat or dog) | multi-class image classification - a classification task in which the model has to predict between n-classes (eg. cat, dog, horse or bear) | multi-label image classification - a classification task in which the model has to predict between n-classes and in each prediction there can be one or more than one predictions. (eg. cat and dog) | Throughout this blog we will make use of the Plant Pathology dataset from Kaggle to understand how the different techniques can be applied. . So first, lets understand our dataset. . from google.colab import drive drive.mount(&#39;/content/drive&#39;) . Mounted at /content/drive . !pip uninstall fastai -q -y !pip install fastai --upgrade -q . |████████████████████████████████| 194kB 17.2MB/s |████████████████████████████████| 61kB 9.7MB/s . from fastai.vision.all import * from sklearn.model_selection import StratifiedKFold . SEED=101 set_seed(SEED) path = Path(&#39;/content/drive/MyDrive/colab_notebooks/fastai/plant_pathology/data&#39;) train = pd.read_csv(path/&#39;train.csv&#39;) train.head(3) . image_id healthy multiple_diseases rust scab . 0 Train_0 | 0 | 0 | 0 | 1 | . 1 Train_1 | 0 | 1 | 0 | 0 | . 2 Train_2 | 1 | 0 | 0 | 0 | . Let&#39;s look at the data. As can see from the above, our train.csv contains the image_id and the labels. There are four classes - healthy, multiple_diseases, rust and scab . train[&#39;labels&#39;] = train.iloc[:, 1:].idxmax(1) train[&#39;labels&#39;].value_counts(), len(train) . (rust 622 scab 592 healthy 516 multiple_diseases 91 Name: labels, dtype: int64, 1821) . In total, there are 1,821 train images. Except for the multiple_diseases class, all other classes have similar number of training examples. One of the problems with this dataset is the relatively low number of multiple_diseases examples in the dataset. Later, we will see how we can use oversampling to help with this. . Now let&#39;s start with the first technique. . 1. k-fold crossvalidation . Oftentimes, training data is scarce and you might want to use all the given data in training but because in crossvalidation (train-validation split) some percentage of data is kept for validation, and that data becomes unavailable for training our model. This is where k-fold crossvalidation could be useful. How does this work? . Create k folds of validation data | Train k models using different validation set each time | During inference, make prediction on all k models and average the results | This way not only we will be ensembling k models during inference, we would also use all the data in the training process. . Let&#39;s see how this is done. . N_FOLDS = 3 train[&#39;fold&#39;] = -1 strat_kfold = StratifiedKFold(n_splits=N_FOLDS, shuffle=True) for i, (_, test_index) in enumerate(strat_kfold.split(train.image_id.values, train[&#39;labels&#39;].values)): train.iloc[test_index, -1] = i train[&#39;fold&#39;] = train[&#39;fold&#39;].astype(&#39;int&#39;) . train.head(5) . image_id healthy multiple_diseases rust scab labels fold . 0 Train_0 | 0 | 0 | 0 | 1 | scab | 2 | . 1 Train_1 | 0 | 1 | 0 | 0 | multiple_diseases | 2 | . 2 Train_2 | 1 | 0 | 0 | 0 | healthy | 0 | . 3 Train_3 | 0 | 0 | 1 | 0 | rust | 1 | . 4 Train_4 | 1 | 0 | 0 | 0 | healthy | 2 | . train[&#39;fold&#39;].value_counts() . 2 607 1 607 0 607 Name: fold, dtype: int64 . train.groupby([&#39;fold&#39;, &#39;labels&#39;]).size() . fold labels 0 healthy 172 multiple_diseases 30 rust 207 scab 198 1 healthy 172 multiple_diseases 31 rust 207 scab 197 2 healthy 172 multiple_diseases 30 rust 208 scab 197 dtype: int64 . So we have created three validation sets with each sets having 607 samples. Also because we used stratified k-fold, the different classes in each validation sets are about the same. Now we are ready to proceed with training our k models. . 2. Oversampling and undersampling . As we saw earlier, multiple_diseases class has only 90 samples as compared to others averaging around 500+. This might disadvantage the multiple_diseases class as the model might learn to predict multiple_diseases less often to improve the metrics. . In such scenarios, oversampling can be used. Oversampling is nothing but copy-pasting the same training data of a certain class to increase its numbers. . Let&#39;s see how this is done. . def oversampling(df, fold, col2os=&#39;multiple_diseases&#39;, oversampling=3): train_df_no_val = df[df[&#39;fold&#39;] != {fold}] #training set train_df_just_val = df[df[&#39;fold&#39;] == {fold}] #validation set #we only want oversample the multiple_disease class in the training set train_df_bal = pd.concat( [train_df_no_val[train_df_no_val[&#39;labels&#39;] != col2os], train_df_just_val] + [train_df_no_val[train_df_no_val[&#39;labels&#39;] == col2os]] * oversampling ).sample(frac=1.0, random_state=SEED).reset_index(drop=True) train_df_bal.reset_index(drop=True) return train_df_bal . train_os = oversampling(train, 0) . len(train), len(train_os) . (1821, 2003) . train_fold0 = train[train[&#39;fold&#39;] != 0] train_os_fold0 = train_os[train_os[&#39;fold&#39;] != 0] . (print(&#39;train without oversamplig&#39;, &#39; n n&#39;, train_fold0[&#39;labels&#39;].value_counts(), &#39; n n&#39;, &#39;train with oversampling&#39;, &#39; n n&#39;, train_os_fold0[&#39;labels&#39;].value_counts(), sep=&quot;&quot;)) . train without oversamplig rust 415 scab 394 healthy 344 multiple_diseases 61 Name: labels, dtype: int64 train with oversampling rust 415 scab 394 healthy 344 multiple_diseases 183 Name: labels, dtype: int64 . As we can see we have 3x our multiple_diseases class after using oversampling. Samples of other classes stay the same. Oversampling as well as its counterpart undersampling can be useful in balancing the sample size of different classes in the dataset. This allows the model to be trained with less bias towards any of the classes. . 3. Techniques from fastbook Chapter 7 . Fastbook is an amazing resource to learn DL and it is my go to resource. In Chapter 7, advanced techniques for training an image classification model are introduced. Let&#39;s see what these techniques are. . Normalization | Data augmentation including MixUp (CutMix) | Progressive resizing | Test time augmentation | Normalization . We know that having the mean and std of our input data around 0 and 1 helps the model train more efficiently and helps in generalization. Hence, normalization is almost a default technique these days. . Generally, when we train image classification we start by transfer learning. These models would have been generally trained using the ImageNet dataset. Hence, when we normalize our data we use the mean and std of ImageNet dataset to normalize our data. . If we are training from scratch, it&#39;s recommended to calculate the mean and std of the dataset for the 3-channels and use that to normalize the data. Also, during inference, the test data should be normalized using whatever stats that were used to normalize during the training. . Doing this in fastai is very easy. Let&#39;s take a look. . def get_dls(fold, df, img_sz=224): datablock = DataBlock( blocks=(ImageBlock, CategoryBlock()), getters=[ ColReader(&#39;image_id&#39;, pref=path/&#39;images&#39;, suff=&#39;.jpg&#39;), ColReader(&#39;labels&#39;) ], splitter=IndexSplitter(df.loc[df.fold==fold].index), item_tfms=Resize(img_sz), ) return datablock.dataloaders(source=df, bs=32) . dls = get_dls(0, train_os) x, y = dls.one_batch() x.mean(dim=[0,2,3]),x.std(dim=[0,2,3]) . (TensorImage([0.3879, 0.5049, 0.2897], device=&#39;cuda:0&#39;), TensorImage([0.1893, 0.1820, 0.1703], device=&#39;cuda:0&#39;)) . Our mean and std are nowhere near 0 and 1. . Below is how we could calculate the mean and std of our dataset. . Note: This would only use the train dataset. Hence, a more stringent way would be to use all images and calculate the mean and std. . m,s = [0., 0., 0.], [0., 0., 0.] count = 0 for x, y in next(iter(dls)): m += np.array(x.mean(dim=[0,2,3]).cpu()) s += np.array(x.std(dim=[0,2,3]).cpu()) count += 1 . m/count , s/count . (array([0.39644337, 0.51481164, 0.30797708]), array([0.19386025, 0.17980762, 0.17882748])) . Let&#39;s modify our get_dls function slightly in the batch_tfms argument. We have normalize and are using imagenet_stats to normalize the data. Let&#39;s see what is imagenet_stats first and see how this has changed our mean and std. . def get_dls(fold, df, img_sz): datablock = DataBlock( blocks=(ImageBlock, CategoryBlock()), getters=[ ColReader(&#39;image_id&#39;, pref=path/&#39;images&#39;, suff=&#39;.jpg&#39;), ColReader(&#39;labels&#39;) ], splitter=IndexSplitter(df.loc[df.fold==fold].index), item_tfms=Resize(img_sz), batch_tfms=[Normalize.from_stats(*imagenet_stats)] ) return datablock.dataloaders(source=df, bs=32) . As can be seen below, imagenet_stats is a tuple that has the mean and std for the three channels. If you have the stats for your dataset, you could also pass it similarly to normalize the data. . imagenet_stats . ([0.485, 0.456, 0.406], [0.229, 0.224, 0.225]) . dls = get_dls(0, train_os, 224) x, y = dls.one_batch() x.mean(dim=[0,2,3]),x.std(dim=[0,2,3]) . (TensorImage([-0.3794, 0.2188, -0.4551], device=&#39;cuda:0&#39;), TensorImage([0.9271, 0.8399, 0.8564], device=&#39;cuda:0&#39;)) . The mean and std following normalization is much closer to 0 and 1. . Data augmentation, MixUp and CutMix . Data augmentation is a well known technique to improve image classification. Fastai provides many of these data augmentation tools and they can be easily applied while creating the dataloaders like how we normalized earlier. Data augmentation can be passed as an argument in either item_tfms or batch_tfms while creating our datablock. The difference between the both is that the former make use of CPU while the latter make use of GPU. Hence, batch_tfms is the preferred method to carry out most of the augmentation. . Data augmentation essentially allows us to enlarge our dataset size without getting new data. Data augmentation essentially uses synthetic data manipulation to create new images/training data. . Let&#39;s use this image to see some examples of the many data augmentation that comes with fastai. . img = PILImage(PILImage.create((path/&#39;images&#39;).ls()[SEED]).resize((600,400))) img . _,axs = subplots(2, 4) for ax in axs.flatten(): show_image(FlipItem(p=0.5)(img, split_idx=0), ctx=ax) . _,axs = subplots(2, 4) for ax in axs.flatten(): show_image(DihedralItem(p=1.)(img, split_idx=0), ctx=ax) . _,axs = subplots(2, 4) for ax in axs.flatten(): show_image(RandomCrop(224)(img, split_idx=0), ctx=ax) . And aug_transforms which is an &quot;Utility func to easily create a list of flip, rotate, zoom, warp, lighting transforms.&quot; . timg = TensorImage(array(img)).permute(2,0,1).float()/255. def _batch_ex(bs): return TensorImage(timg[None].expand(bs, *timg.shape).clone()) . tfms = aug_transforms(pad_mode=&#39;zeros&#39;, mult=2, min_scale=0.5) y = _batch_ex(9) for t in tfms: y = t(y, split_idx=0) _,axs = plt.subplots(2,3, figsize=(12,10)) for i,ax in enumerate(axs.flatten()): show_image(y[i], ctx=ax) . MixUp . MixUp is a data augmentation technique that was introduced in 2018 in this paper. So what happens during a MixUp? . for a training image image_1, a second image image_2 is randomly selected | new_image is created following this formula where alpha is a constant between 0. and 1.0 that is used to mix the two images | new_image = alpha * image_1 + (1-alpha) * image_2 . similarly, the targets of image_1 and image_2 are blended to create new_target | For example, let&#39;s assume we are training a 4-class model and the &gt;one-hot-encode for image_1 is [0., 0., 1., 0.] and image_2 is [0., 0., &gt;0., 1.]. Also, let&#39;s assume alpha is 0.3. The target for our new_image is &gt;[0., 0., 0.3, 0.7]. . new_target = 0.3 * [0., 0., 1., 0.] + (1-0.3) * [0., 0., 0., 1.] . With this, now, we have completely new image for training. | mixup = MixUp(1.) with Learner(dls, nn.Linear(3,4), loss_func=CrossEntropyLossFlat(), cbs=mixup) as learn: learn.epoch,learn.training = 0,True learn.dl = dls.train b = dls.one_batch() learn._split(b) learn(&#39;before_batch&#39;) _,axs = plt.subplots(3,3, figsize=(9,9)) dls.show_batch(b=(mixup.x,mixup.y), ctxs=axs.flatten()) . epoch train_loss valid_loss time . 0 | 00:01 | . As can be seen, some of our images above look a bit smeared/odd that is because of mixup. As can be seen, using MixUp with fastai is relatively easy. It is passed as a callback argument when we initiate a Learner. It can also be passed as a cbs in fit_one_cycle. . learn.fit_one_cycle(3, cbs=MixUp(1.0)) . #a distribution the size of batch_size hence the alpha varies from one image to another #an example of generating the alpha distribution torch.distributions.beta.Beta(tensor(1.), tensor(1.)).sample((10,)) . tensor([0.4794, 0.3758, 0.1914, 0.6586, 0.6198, 0.5889, 0.1123, 0.9081, 0.2395, 0.4103]) . CutMix . Although CutMix was not covered in the book, it has been added to the fastai library. CutMix is similar to MixUp but instead of blending images together, CutMix works by cropping a portion of image_2 and placing it in image_1. CutMix has been shown to work better than MixUp. . . Source: CutMix: Regularization Strategy to Train Strong Classifiers with Localizable Features . Let&#39;s see some examples of CutMix in action . cutmix = CutMix(1.) with Learner(dls, nn.Linear(3,4), loss_func=CrossEntropyLossFlat(), cbs=cutmix) as learn: learn.epoch,learn.training = 0,True learn.dl = dls.train b = dls.one_batch() learn._split(b) learn(&#39;before_batch&#39;) _,axs = plt.subplots(3,3, figsize=(9,9)) dls.show_batch(b=(cutmix.x,cutmix.y), ctxs=axs.flatten()) . epoch train_loss valid_loss time . 0 | 00:01 | . Progressive resizing . As stated in the book, progressive resizing gradually uses larger and larger images as we continue our training. This technique is akin to transfer learning. Our model learns on smaller images and as we increase the image size it carries forward what it had learnt in previous training as well as picks up something additional from the larger images. . Test time augmentation . As taken from the fastbook, &quot;test time augmentation (TTA): During inference or validation, creating multiple versions of each image, using data augmentation, and then taking the average or maximum of the predictions for each augmented version of the image.&quot; . Other things . Different architectures . Generally varying sizes of ResNet would be the first model to try and establish a baseline. After which one could explore other architecture such as efficientnet or the recently released Visual Transformer. . Transfer Learning . In most cases, transfer learning works really well hence it could be the first thing to try for most classification tasks. . 4. Techniques I learned from Zach&#39;s walkwithfastai imagewoof lecture . I highly recommend walkwithfastai course. It is also my go to resource for fastai. In this particular notebook, Zach introduces different techniques that seem to work really well for image classification tasks. Please check the notebook for references and details. Zach also has a lecture using this notebook here. . The notebook introduces the following techniques. . xresnet which is an arch based on the &quot;Bag of Tricks for ResNet&quot; paper | Mish - a new activation function | ranger - a new optimizer that combines RAdam and Lookahead | Self-attention | MaxBlurPool | a different LR scheduler - that uses flatten+anneal scheduling | Label Smoothing Cross Entropy | 5. Softlabeling and progressive label correction . Softlabeling . I came across softlabeling through Isaac Flath&#39;s amazing blog. I think the blog is the best place to get started on softlabeling. . In supervised learning, labels, which are created by humans, could be erroneous. This leads to the labels being &#39;noisy&#39;. This was the case in the Plant Pathology competition and the winner used a similar method (softlabeling) in the winning solution. . How do we deal with such noisy labels? One way is to punish the model less for predicting incorrectly a noisy label. The steps are as follows . Create a k-fold crossvalidation | Train k classifier using different k-fold for sufficient epochs using the noisy labels | Use the classifier to predict on the kth validation set and save the prediction | Upon completion of the above step, you will have two labels - one the noisy label that came with the data label_ori and another predicted by the above classifiers label_pred | Finally, train your actual classifier and this time when labels between label_ori and label_pred differs, adjust the labels using a hyperparameter a | For example, let&#39;s assume we are training a 4-class model and the one-hot-encode for label_ori is [0., 0., 1., 0.] and label_pred is [0., 0., 0., 1.]. Also, let&#39;s assume a is 0.5. Our new_label would be [0., 0., 0.5, 0.5]. By doing this, the model would be punished less for predicting the wrong class as this could be due to noisy labels. . a = 0.5 label_ori = [0., 0., 1., 0.] label_pred = [0., 0., 0., 1.] new_label = a * label_ori + (1-a) * label_pred new_label = [0., 0., 0.5, 0.5] . Progressive Label Correction . I came across this technique in thsi wonderful Kaggle Notebook by Kerem Turgutlu. It is a paper implementation of this paper. . Again, this method works in cases where there are noisy labels in the dataset. This is my understanding of how it is implemented. . During model training, we let a model train normally for a warm_up period. In the above implementation, the warm_up period was 20% of the total iterations. | Once training goes over the warm_up iterations, Progressive Label Correction (PLC) kicks-in | In PLC, after an iteration, mislabeled indexes are identified | Then, we calculate the probabilities of the max prediction class (predicted_probas - the class the model predicted) as well as the actual target class (actual_probas - the class the model should have predicted) of the mislabeled indexes | we check if the absolute difference between predicted_probas and the actual_probas is above a theta value (theta is a hyperparameter we set) | if the difference is higher, then for those mislabeled indexes, we change (‘correct’) the label y to be that predicted by the model | we continue step 2 to step 6 while progressively lowering the theta using a scheduler function (linear scheduler was used in the above notebook). | Let&#39;s take a look what the ProgressiveLabelCorrection callback in the notebook does. . dls = get_dls(0, train_os, 128) . learn = cnn_learner(dls, resnet18, pretrained=True) . learn.fit_one_cycle(1) learn.one_batch(5, learn.dls.one_batch()) . . 0.00% [0/1 00:00&lt;00:00] epoch train_loss valid_loss time . 0 | 1.573150 | 1.102266 | 02:34 | . . 28.57% [6/21 01:46&lt;04:27 1.5732] preds_max = learn.pred.argmax(-1) mislabeled_idxs = preds_max != learn.y #so we have 32 samples in each iteration (which is the batch_size), of which 8 are mislabelled mislabeled_idxs, len(mislabeled_idxs), mislabeled_idxs.float().sum() . (TensorCategory([False, True, False, True, False, True, False, False, False, False, True, False, False, False, False, False, False, False, True, False, False, False, False, False, False, True, False, True, True, False, False, False], device=&#39;cuda:0&#39;), 32, TensorCategory(8., device=&#39;cuda:0&#39;)) . # we also index into the mislabelled targets mislabeled_probas = learn.pred[mislabeled_idxs].softmax(-1) mislabeled_targs = learn.y[mislabeled_idxs] . predicted_probas = mislabeled_probas.max(-1).values predicted_probas . tensor([0.7182, 0.6797, 0.6050, 0.6181, 0.4840, 0.4588, 0.5954, 0.7079], device=&#39;cuda:0&#39;, grad_fn=&lt;MaxBackward0&gt;) . predicted_targs = mislabeled_probas.max(-1).indices predicted_targs . tensor([2, 1, 0, 3, 0, 0, 1, 2], device=&#39;cuda:0&#39;) . eye = torch.eye(dls.c).to(&#39;cuda&#39;) actual_probas = mislabeled_probas[eye[mislabeled_targs].bool()] actual_probas . tensor([0.1144, 0.2731, 0.2278, 0.2835, 0.3380, 0.2353, 0.3692, 0.1910], device=&#39;cuda:0&#39;, grad_fn=&lt;IndexBackward&gt;) . theta = 0.3 msk = torch.abs(predicted_probas - actual_probas) &gt; theta #there are 5 items that meets the condition msk . tensor([ True, True, True, True, False, False, False, True], device=&#39;cuda:0&#39;) . new_targs = learn.dls.tfms[1][1].vocab[predicted_targs[msk]] new_targs . (#5) [&#39;rust&#39;,&#39;multiple_diseases&#39;,&#39;healthy&#39;,&#39;scab&#39;,&#39;rust&#39;] . Now that we have the new_targs we will update the labels for these indexes in the training set with new_targs. The theta used is progressively lowered. Hence, as the training progresses we would progressively correct the targets even if the difference between probability of the predicted class and predicted probability of actual target class is small. This means as the training progresses we take the prediction by the model as the actual instead of the label that came with the data. . That&#39;s the end of the blog. Please feel free to contact me at @arshyma (Twitter) or marshath@gmail.com if there is anything. Thank you :) .",
            "url": "https://moarshy.github.io/blogs/image_classification/fastai/2021/01/31/first-blog.html",
            "relUrl": "/image_classification/fastai/2021/01/31/first-blog.html",
            "date": " • Jan 31, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://moarshy.github.io/blogs/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://moarshy.github.io/blogs/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://moarshy.github.io/blogs/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://moarshy.github.io/blogs/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}